/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tetris_game_panel;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Random;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import javax.swing.JOptionPane;
import tetris_board.BoardTetris;
import tetris_piece.PieceColor;
import tetris_piece.PieceTetris;
import tetris_piece.PieceTranslation;
import tetris_piece.Point;

/**
 *
 * @author Patricia Pieroni
 */
public class GamePanel extends javax.swing.JPanel implements Runnable {

    public static BoardTetris board;
    public static int blocksize;
    public static PieceTetris fallingpiece;
    public static boolean gameover, restart;
    public static Random random;
    public static ScheduledThreadPoolExecutor animator;
    public static int cols;
    public static int rows;
    static long delayToStart;
    static long step;

    /**
     * Creates new form GamePanel
     */
    public GamePanel() {
        initComponents();
    }

    /**
     * Semea o gerador aleatório, para que a sequência de peças nao fique
     * repetindo.
     *
     * @param blocksize
     * @param cols
     * @param rows
     * @param seed
     */
    public GamePanel(int blocksize, int cols, int rows, int seed) {
        this(rows, cols, blocksize);
        random = new Random(seed);
    }

    /**
     * Recebe o número de linhas, colunas e o tamanho de cada bloco, inicializa
     * algumas variáveis e habilita input do teclado.
     *
     * @param rows
     * @param cols
     * @param blocksize
     */
    public GamePanel(int rows, int cols, int blocksize) {
        restart = false;
        this.blocksize = blocksize;
        this.setPreferredSize(new Dimension(cols * blocksize, rows * blocksize));
        setDoubleBuffered(true);
        random = new Random();
        board = new BoardTetris(rows, cols);
        GamePanel.cols = cols;
        GamePanel.rows = rows;

        setFocusable(true);
        requestFocus();
        addKeyWatcher();

    }


    /*variáveis board, fallingPiece e gameOver mantem o estado atual do game,
    e são resetadas neste metodo*/
    public void startNewGame() {
        gameover = false;
        board.resetBoard();
        fallingpiece = randomPiece();

        delayToStart = 100L;
        step = 1000L / 4;

        animator = null;
        animator = new ScheduledThreadPoolExecutor(1);
        animator.scheduleAtFixedRate(this, delayToStart, step, TimeUnit.MILLISECONDS);

    }

    private PieceTetris randomPiece() {
        int type = random.nextInt(7);
        int rot = random.nextInt(4);

        PieceTetris piece = new PieceTetris();
        piece.blocksize = GamePanel.blocksize;
        piece.type = type;
        piece.rotation = rot;

        int x = blocksize * (cols / 2 + PieceTranslation.TRANSLATIONS[type][rot][0]);
        int y = blocksize * PieceTranslation.TRANSLATIONS[type][rot][1];

        piece.position = new Point(x, y);

        return piece;
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        renderGame(g);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     *
     * Logica do jogo, se for game over a thread é interrompida, se nao a peca
     * continua a cair.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void run() {

        if (gameover) {
            animator.shutdown();
        }

        if (BoardTetris.canMoveDown(fallingpiece)) {
            fallingpiece.moveDown();
        } else {
            //quando a peca repousa, board atualiza e verifica linhas completadas
            BoardTetris.updateBoard(fallingpiece);
            int cleared = BoardTetris.checkCompleteRows();

            //checa duas condicoes de game over e atualiza o fallingpiece
            addNewPiece();
        }
        repaint();

    }

    private void addKeyWatcher() {
        addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (GamePanel.gameover) {
                    return;
                }

                int key = e.getKeyCode();
                switch (key) {
                    case KeyEvent.VK_SPACE:
                        if (BoardTetris.canMoveDown(fallingpiece)) {
                            GamePanel.fallingpiece.moveDown();
                        }
                        break;
                    case KeyEvent.VK_LEFT:
                        if (BoardTetris.canMoveLeft(GamePanel.fallingpiece)) {
                            GamePanel.fallingpiece.moveLeft();
                        }
                        break;
                    case KeyEvent.VK_RIGHT:
                        if (BoardTetris.canMoveRight(GamePanel.fallingpiece)) {
                            GamePanel.fallingpiece.moveRight();
                        }
                        break;
                    case KeyEvent.VK_UP:
                    case KeyEvent.VK_NUMPAD3:
                        if (BoardTetris.canRotateCW(GamePanel.fallingpiece)) {
                            GamePanel.fallingpiece.rotateClockWise();
                        }
                        break;
                    case KeyEvent.VK_DOWN:
                    case KeyEvent.VK_NUMPAD1:
                        if (BoardTetris.canRotateCCW(GamePanel.fallingpiece)) {
                            GamePanel.fallingpiece.rotateCounterClockWise();
                        }
                        break;
               
                    default:
                        break;
                }

                new GamePanel().repaint();
            }
        });

    }

    /**
     * Verifica duas situacoes de game over
     */
    private void addNewPiece() {

        //1 situacao: fora da tela
        if (BoardTetris.pieceLandOffScreen(fallingpiece)) {
            gameover = true;
            fallingpiece = null;
        }

        //2 situacao: se cabe no board
        PieceTetris next = randomPiece();
        if (BoardTetris.nextPieceFit(next)) {
            fallingpiece = next;
        } else {
            gameover = true;
            fallingpiece = null;

        }

    }

    private void renderGame(Graphics g) {
        if (fallingpiece != null) {
            fallingpiece.drawPiece(g);
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                int block = BoardTetris.board[i][j + 1];

                if (block != 0) {
                    g.setColor(PieceColor.COLORS[block - 1]);
                    g.fillRect(j * blocksize, i * blocksize, blocksize, blocksize);
                }
            }

        }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
