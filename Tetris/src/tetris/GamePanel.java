/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tetris;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Random;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import javax.swing.JOptionPane;
import tetris.Board;
import tetris.piece.PieceColor;
import tetris.piece.PieceTetris;
import tetris.piece.PieceTranslation;
import tetris.piece.Point;

/**
 *
 * @author Patricia Pieroni
 */
public class GamePanel extends javax.swing.JPanel implements Runnable {

    public Board board;
    public int blockSize;
    public PieceTetris fallingPiece;
    public boolean gameOver, restart;
    public Random random;
    public ScheduledThreadPoolExecutor animator;
    public int cols;
    public int rows;
    static long delayToStart;
    static long step;

    /**
     * Creates new form GamePanel
     */
    public GamePanel() {
        initComponents();
    }

    /**
     * Semea o gerador aleatório, para que a sequência de peças nao fique
     * repetindo.
     *
     * @param blocksize
     * @param cols
     * @param rows
     * @param seed
     */
    public GamePanel(int rows, int cols, int blockSize, int seed) {
        this(rows, cols, blockSize);
        random = new Random(seed);
    }

    /**
     * Recebe o número de linhas, colunas e o tamanho de cada bloco, inicializa
     * algumas variáveis e habilita input do teclado.
     *
     * @param rows
     * @param cols
     * @param blocksize
     */
    public GamePanel(int rows, int cols, int blocksize) {
        restart = false;
        this.blockSize = blocksize;
        this.setPreferredSize(new Dimension(cols * blocksize, rows * blocksize));
        setDoubleBuffered(true);
        random = new Random();
        board = new Board(rows, cols);
        this.cols = cols;
        this.rows = rows;
        fallingPiece = randomPiece();
        setFocusable(true);
        requestFocus();
        addKeyWatcher();

    }


    /*variáveis board, fallingPiece e gameOver mantem o estado atual do game,
    e são resetadas neste metodo*/
    public void startNewGame() {
        gameOver = false;
        board.reset();
        fallingPiece = randomPiece();
        delayToStart = 100L;
        step = 1000L / 4;
        animator = null;
        animator = new ScheduledThreadPoolExecutor(1);
        animator.scheduleAtFixedRate(this, delayToStart, step, TimeUnit.MILLISECONDS);

    }

    protected PieceTetris randomPiece() {
        int kind = random.nextInt(7);
        int rot = random.nextInt(4);

        PieceTetris piece = new PieceTetris();
        piece.blockSize = this.blockSize;
        piece.kind = kind;
        piece.rotation = rot;

        int x = blockSize * (cols / 2 + PieceTranslation.TRANSLATIONS[kind][rot][0]);
        int y = blockSize * PieceTranslation.TRANSLATIONS[kind][rot][1];

        piece.position = new Point(x, y);

        return piece;
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        renderGame(g);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     *
     * Logica do jogo, se for game over a thread é interrompida, se nao a peca
     * continua a cair.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void run() {

        if (gameOver) {
            animator.shutdown();
        }

        if (board.canMoveDown(fallingPiece)) {
            fallingPiece.moveDown();
        } else {
            //quando a peca repousa, board atualiza e verifica linhas completadas
            board.updateBoard(fallingPiece);
            int cleared = board.checkCompleteRows();

            //checa duas condicoes de game over e atualiza o fallingpiece
            addNewPiece();
        }
        repaint();

    }

    private void addKeyWatcher() {
        addKeyListener(
                new KeyAdapter() {
            public void keyPressed(KeyEvent e) {
                if (gameOver) {
                    return;
                }

                int key = e.getKeyCode();
                if (key == KeyEvent.VK_SPACE) {

                } else if (key == KeyEvent.VK_LEFT) {
                    if (board.canMoveLeft(fallingPiece)) {
                        fallingPiece.moveLeft();
                    }

                } else if (key == KeyEvent.VK_RIGHT) {
                    if (board.canMoveRight(fallingPiece)) {
                        fallingPiece.moveRight();
                    }

                } else if (key == KeyEvent.VK_UP || key == KeyEvent.VK_NUMPAD3) {
                    if (board.canRotateCW(fallingPiece)) {
                        fallingPiece.rotateClockWise();
                    }
                } else if (key == KeyEvent.VK_DOWN || key == KeyEvent.VK_NUMPAD1) {
                    if (board.canRotateCCW(fallingPiece)) {
                        fallingPiece.rotateCounterClockWise();
                    }
                }

                repaint();
            }
        });
    }

    /**
     * Verifica duas situacoes de game over
     */
    protected void addNewPiece() {

        //1 situacao: fora da tela
        if (board.pieceLandOffScreen(fallingPiece)) {
            gameOver = true;
            fallingPiece = null;
            return;
        }

        //2 situacao: se cabe no board
        PieceTetris next = randomPiece();
        if (board.willFitNext(next)) {
            fallingPiece = next;
        } else {
            fallingPiece = null;
            gameOver = true;

        }

    }

    private void renderGame(Graphics g) {
        if (fallingPiece != null) {
            fallingPiece.draw(g);
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                int block = board.board[i][j + 1];

                if (block != 0) {
                    g.setColor(PieceColor.COLORS[block - 1]);
                    g.fillRect(j * blockSize, i * blockSize, blockSize, blockSize);
                }
            }
        }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
